# 第四章 表达式
### 4.01
> 表达式5 + 10 \* 20 / 2的求值结果是多少？

105

### 4.02
> 根据4.12节中的表，在下述表达式的合理位置添加括号，使得添加括号后运算对象的组合顺序与添加括号前一致。
```
*(vec.begin())        // *vec.begin()
(*(vec.begin())) + 1  // *vec.begin()+1
```

### 4.03
> C++语言没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了余地。这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡，你认为这可以接受吗？请说出你的理由。

可以接受, 只要遵守不要在一个表达式中用上超过两次某个可能修改的对象即可避免

### 4.04
> 在下面的表达式中添加括号，说明其求值过程及最终结果。编写程序编译该（不加括号的）表达式并输出结果验证之前的推断。
```
// 12 / 3 * 4 + 5 * 15 + 24 % 4 / 2
// 16 + 75 + 0 = 91
```

### 4.05
> 写出下列表达式的求值结果。
```
-30 * 3 + 21 / 5  // -86
-30 + 3 * 21 / 5  // -18
30 / 3 * 21 % 5   // 0
-30 / 3 * 21 % 4  // -2
```

### 4.06
> 写出一条表达式用于确定一个整数是奇数还是偶数。
```c++
if(n%2) ... // 是奇数
else ... // 是偶数
```

### 4.07
> 溢出是何含义？写出三条将导致溢出的表达式。
```c++
// 溢出 超出类型描述范围, 发生模循环
// 64位机器字长
unsigned a = 4294967295; a += 1;
int b = -2147483648; b -= 1;
short c = 32767; c += 1;
```

### 4.08
> 说明在逻辑与、逻辑或及相等性运算符中运算对象的求值顺序。

1. && 假短路
2. || 真短路
3. ? : 先判断, 真前假后
4. 其他未定义求值顺序

### 4.09
> 解释在下面的if语句中条件部分的判断过程。
```c++
const char *cp = "Hello World";
if (cp && *cp) // cp 是非空指针 且 所指char非 '\0'
```

### 4.10
> 为while 循环写一个条件，使其从标准输入中读取整数，遇到 42 时停止。
```c++
while(std::cin >> a && a != 42){...}
```

### 4.11
> 书写一条表达式用于测试4个值a、b、c、d的关系，确保a大于b、b大于c、c大于d。
```c++
if(a > b && b > c && c > d) ...
```

### 4.12
> 假设i、j 和k 是三个整数，说明表达式 i != j < k 的含义。

首先判断 j \< k , 再判断 i 是否与结果 ( bool ) 相等

### 4.13
> 在下述语句中，当赋值完成后 i 和 d 的值分别是多少？
```c++
int i; double d;
d = i = 3.5; // i = 3, d = 3.0
i = d = 3.5; // d = 3.5, i = 3
```

### 4.14\*
> 行下述 if 语句后将发生什么情况？
```c++
if (42 = i)   // 42 非 左值, 编译错误
if (i = 42)   // 恒为真, 逻辑错误
```

### 4.15
> 下面的赋值是非法的，为什么？应该如何修改？
```c++
double dval; int ival; int *pi;
dval = ival = pi = 0;
// pi = nullptr;
// ival = 0;
// dval = 0.0;
```

### 4.16
> 尽管下面的语句合法，但它们实际执行的行为可能和预期并不一样，为什么？应该如何修改？
```c++
if (p = getPtr() != 0)  // if ((p = getPtr()) != 0 )
if (i = 1024)  // if(1024 == i)
```

