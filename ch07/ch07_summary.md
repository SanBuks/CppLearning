# 第七章 类

## 1. 定义抽象数据类型
### 类的思想
- 类的思想 : 数据抽象和封装
- 数据抽象 : 定义一个抽象数据类, 其中接口(定义操作)和实现(数据成员和函数)分离, 通过实例化对象来使用相关接口
- 封装 : 接口和实现分离, 访问控制加强了封装性, 使用者了解接口即可使用, 设计者仅根据接口要求自行改变实现细节

### 成员函数
- 成员函数通过 this常量指针 来调用对象, 定义在类中函数为隐式内联函数, 类外则非内联函数可用 inline 显示声明为内联函数
- 常量成员函数的 const 加在参数列表后面, 修改this的属性为指向常量对象的常量指针
```c++
class A{    
    std::string isbn() const {};
    // 等价为
    // std::string isbn(const className * const this);
	
	const int &ff(int a) const { return a;} // 返回 int & 则出错,不可修改成员
	int &ff(const int &a){ return a; }  // 根据类A是否是const发生调用ff()的重载
	// 成员函数的const重载 : 基于对象是否是const,存在基于const的成员函数重载,类似于(const int \*p)和(int \*p)的重载(函数匹配等级第二级)
	int a=3; 
	// 类中编译规则: 先编译成员声明,再编译成员的函数体(如果有),因此数据成员可以随意放
};
```

- 成员函数返回 \*this 可以作为 类的左值使用, 符合赋值运算符的结果, const成员函数 返回 \*this, 则返回类型是常量引用
- mutable : 修饰数据成员, mutable 成员可在 const成员函数 和 const类对象 中被修改

### 构造函数
- 构造函数 : 控制初始化过程, 对象被创建就会执行, 可重载
- 构造函数规则 : 与类同名, 无返回, 非const
- 默认构造函数 : 空参或都提供默认实参的构造函数, 使用默认构造函数的情况 :
    - 不用初始值定义一个类对象或者定义局部静态对象如`className obj;`
    - 含有类成员的类使用默认构造函数或始化列表中未初始化类成员
    - 数组的初始化值个数小于数组大小和类似`vector<T> vec(n)`的调用

- 合成的默认构造函数 : 没有自定义构造函数时由编译器生成, 或者用`=default`要求显示合成(内部默认内联, 外部不内联), 依次完成两件事 : 
    - 存在类内的初始值, 则用它初始化类成员( 类对象的类内初始值须用 = 或 {} )
    - 默认初始化成员( 作用块中的内置成员默认初始值未定义 )

- 委托构造函数 : 在参数列表中调用其他的构造函数, 执行顺序 : 
	- 1. 从委托的构造函数初始化列表 -> 
	- 2. 委托构造函数的函数体 -> 
	- 3. 构造函数的函数体

### 初始值列表
- 初始值类列表初始化了成员并简化了构造函数体
```c++
class A{
	int d1, d2, &d3;
public:
    // 1. 初始化顺序按声明顺序来, 并不按列表顺序
    // 2. const 或 引用等成员必须使用初始值列表来初始化,不能用函数体赋值语句
	A(int a1) : d3(d1), d1(a1){ // d1先初始化, d2默认初始化, d3最后初始化
        // 初始值列表初始化优先于类内初始值
		d1=2; // d1后在函数体中再次被赋值
	}  
};
```

### 类的作用域
- 类外定义函数的作用域 : 
```c++
ClassName::AliasType ClassName::Funcname(const int &a) const {....} 
//ClassName::后的参数列表,函数体都处于类作用域中,返回值类型默认不在,可加上Classname:: 补充
```

- 类中类型别名 : 类中的类型别名需要先定义再使用, 一般类开头且是public
- 重复使用类型别名 : 成员使用了外层作用域中的某个类型别名, 那么在类中就不能重新定义该名字,否则会发生错误
- 名字查找规则 : 
    - 成员函数体内查找,注意包含形参的隐式定义
    - 类中所有成员
    - 成员函数定义前的作用域内查找 (注意 ! 包含类定义到类外定义的范围) 

```c++
class A{
public : 
	int ff();
};
int a=3;
int A::ff(){ return a; }  // 从类作用域出来找到了定义之前范围内的 a
```

- `this->attr` 或者 `classname::attr` 可以避免参数名和成员重名的问题, `::var` 可以避免全局变量与成员或者参数重名的问题

## 2. 访问控制
### 访问说明符
- public 说明符后的成员在整个程序内可以访问, 可定义类的接口
- private 说明符后的成员在程序内不可访问, 只能被类的成员函数访问, 可定义数据成员和功能函数
- 说明符可重复使用多次, 范围根据位置进行划分
- class 的默认说明符为private , struct 的默认说明符为public, 除此之外没有区别

### 友元
- 友元定义 : 指允许访问一个类的非public成员的其他类,其他类成员函数或函数, 用friend声明该函数或者类, 友元关系不具备传递性, 其中定义关系如下:
```c++
class Screen;  // 1. 前向声明 类Screen 为不完整类型
// 可以定义不完整类型的指针 或 作为函数的参数或返回类型
// 允许类中包含指向自己的指针和引用
// 在使用时必须被完整定义

class Window_mgr{ // 2. 定义Window_mgr类, 只声明clear函数
    using ScreenIndex = vector<Screen>::size_type;
    void clear(ScreenIndex ); //  clear函数中要使用到Screen类所以只是声明
    ...
};

class Screen{  // 3. 定义Screen类
    friend void Window_mgr::clear(ScreenIndex );
    ... 
};

void Window_mgr::clear(ScreenIndex a){...}  // 4. 具体定义成员函数
```

- 友元定义的位置 : 友元不受访问说明符的影响可以随处放, 一般在类的开始处
- 友元声明 : 类中的友元声明只是指定了访问权限, 需要在类的头文件中额外再进行一次声明, 重载的友元函数需要每个版本都要在类中进行一次友元声明
```c++

struct X{
    friend void f(){...}
    X(){f();}  // 错误, 即使友元f()定义在了内中仍要一个前置的声明
    void g();
	void h();
};
void X::h(){ f(); } // 错误, 即使友元f()定义在了内中仍要一个前置的声明
void f();  // 即使f()定义在了类中,仍然需要再进行一次声明
void X::g(){ f(); }
```


## 3. 其他特性
### 隐式的类类型转换
- 转换构造函数 : 一个参数的构造函数, 该参数类型的对象隐式转换为该类临时量使用, 但不允许二次转换
- `explict`只作用于一个参数构造函数前, 抑制隐式类类型转换(包括拷贝初始化), 同时explict只作用于类中的函数声明前
```c++
class A{
	A(string s){}
	explict A(int a){}
};
void func(A& b){}

string s="123";
func(s); // 正确 , string -> A
func(string("123")); // 正确 , 显示使用构造函数

func("123"); // 错误 , "123" -> string -> A
func(static_cast<A>(123)); // 通过static_cast显示执行了explict构造函数
```

### 聚合类
- 聚合类作用 : 只是将数据成员单纯地聚合在一块, 用户可以直接访问类成员, 有特殊的初始化语法形式
- 聚合类条件 :
    - 所有成员都是 public
    - 没有定义任何构造函数
    - 没有类内初始值
    - 没有虚表
- 聚合类初始化 : `Data var = {0, "123"};` 顺序与声明顺序一致, 剩余默认初始化 

### 字面值常量类
- 成员都是字面值类型的聚合类是字面值常量类
- 自定义的字面值常量类要求 :
    - 至少有一个constexpr构造函数, 空函数体, 初始化所有成员, 可以设为default
    - 必须使用析构函数的默认定义
    - 数据成员都是字面值类型, 存在类内初始值则须是一条常量表达式
    - constexpr成员函数必须符合constexpr函数要求, 且是隐式const成员函数
    - 其他类型类成员须是字面值常量类

### 类的静态成员
- 静态成员 : 类对象不包含任何与静态成员有关的数据, 而是与类共享, 用static修饰类成员
- 静态数据成员 : 只能初始化一次, 定义后一致存在于程序整个声明周期中
- 静态函数成员 : 不能声明成const, 不与任何对象绑定, 没有this指针
```c++
const int B=3;
int A::a=3;  // 1. 类外且类定义之前初始化静态成员, static只出现在类中
class A{
	static int a;
	static constexpr int b=B; 
	// 2. 静态成员一般不在类内初始化如果初始化则满足以下条件 :
	// (1) 静态成员必须是constexpr修饰 
	// (2) 初始值必须是常量表达式
	double aa[b]; 
	// 3. 类内初始化的静态成员只用于编译期替换可以不用在类外定义, 其他情况需要额外定义
    // 4. 类内初始化的静态成员, 类外定义可没有初始值

	static void ff(){...}
	// 5. Classname::ff(); , var.ff(); , pvar->ff(); 三种调用方式
};
```

- 静态成员与非静态的区别 :
    - 静态成员可以是不完全类型比如定义自身类型的数据成员
    - 静态成员可以作为成员函数的默认实参


