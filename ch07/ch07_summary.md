# 第七章 类

## 1. 定义抽象数据类型
### 类的思想
- 类的思想 : 数据抽象和封装
- 数据抽象 : 定义一个抽象数据类, 其中接口(定义操作)和实现(数据成员和函数)分离, 通过实例化对象来使用相关接口
- 封装 : 接口和实现分离, 访问控制加强了封装性, 使用者了解接口即可使用, 设计者仅根据接口要求自行改变实现细节

### 成员函数
- 成员函数通过this常量指针来调用对象,定义在类中函数为隐式内联函数,类外则非内联函数可用inline显示声明为内联函数
```c++
total.isbn();
//等价为
isbn(&total); // this指向类对象
```

- 常量成员函数的const加在参数列表后面,修改this的属性为指向常量对象的常量指针
```c++
class A{    
	const int &ff(int a) const { return a;} // 返回 int & 则出错,不可修改成员
	int &ff(const int &a){ return a; }  // 根据类A是否是const发生调用ff()的重载
	// 成员函数的const重载 : 基于对象是否是const,存在基于const的成员函数重载,类似于(const int \*p)和(int \*p)的重载(函数匹配等级第二级)
	int a=3;  // 类中编译规则: 先编译成员声明,再编译成员的函数体(如果有),因此数据成员可以随意放
};
```
- 成员函数返回 \*this 可以作为 类的左值使用,符合赋值运算符的结果,如果const成员函数返回\*this,则返回类型是常量引用(一般不用const返回\*this)
- mutable : 可以用mutable修饰数据成员,可以在const成员函数内修改或者const类对象调用修改

#### 构造函数
- 构造函数: 控制初始化过程,对象被创建就会执行,可重载
- 构造函数规则: 与类同名,无返回,非const
- 默认构造函数: 空参或都提供默认实参的构造函数,使用默认构造函数的情况:
> - 不用初始值定义一个类对象或者定义局部静态对象如`classname obj;`
> - 含有类成员的类使用默认构造函数或始化列表中未初始化类成员
> - 数组的初始化值个数小于数组大小和类似vector\<T> vec(n);的调用

- 合成的默认构造函数: 没有自定义构造函数时由编译器生成,或者用=default显示要求合成,依次完成两件事: 
> - 存在类内的初始值,则用它初始化类成员
> - 默认初始化成员(作用块中的内置成员默认初始值未定义)

- 委托构造函数: 在参数列表中调用其他的构造函数,执行顺序从委托的构造函数初始化列表到委托构造函数的函数体再到构造函数的函数体

#### 初始值列表
- 初始值类列表初始化了成员并简化了构造函数体
```c++
class A{
	int d1, d2;
public:
	A(int a1):d1(a1){ // 其中d1先在初始值列表中定义并赋予a1值,d2没包含则直接默认初始化
		d1=2; // d1后在函数体中再次被赋值
	}  
};
```
- const 或者 引用等成员必须使用初始值列表来初始化,不能用函数体赋值语句
- 初始化顺序按声明顺序来,并不按列表顺序

#### 赋值,拷贝和析构
- 编译器会合成默认的赋值,拷贝和析构函数,但是只适用于基本内置类型或者完整的类
- 复合类型或者内存分配情况无法应用默认的相应函数
- 可以尽量用vector和string来避免分配释放内存的复杂性

#### 类的作用域
```c++
ClassName::AliasType ClassName::Funcname(const int &a) const {....} 
//ClassName::后的参数列表,函数体都处于类作用域中,返回值类型默认不在,可加上Classname:: 补充
```
- 类中类型别名: 类中的类型别名需要先定义再使用,一般把类中的类型别名定义在开头且是public
- 重复使用类型别名 : 成员使用了外层作用域中的某个类型别名,那么在类中就不能重新定义该名字,否则会发生错误
- 名字查找规则 : 
> - 成员函数体内查找,注意包含形参的隐式定义
> - 类中所有成员
> - 成员函数定义前的作用域内查找(注意,包含类定义到类外定义的范围) 

```c++
class A{
public : 
	int ff();
};
int a=3;
int A::ff(){ return a; }  // 从类作用域出来找到了定义之前范围内的 a
```
- this->attr 或者 classname::attr 可以避免参数名和成员重名的问题, ::var可以避免全局变量与成员或者参数重名的问题



### 2. 访问控制
#### 访问说明符
- public说明符后的成员在整个程序内可以访问,可定义类的接口
- private说明符后的成员在程序内不可访问,只能被类的成员函数访问,可定义数据成员和功能函数
- 说明符可重复使用多次,范围根据位置进行划分
- class 的默认说明符为private , struct 的默认说明符为public,除此之外没有区别

#### 友元
- 友元定义 : 指允许访问一个类的非public成员的其他类,类成员函数或函数,用friend声明该函数或者类,友元关系不具备传递性,其中定义关系如下:
```c++
class Screen;  // 1. 前向声明类Screen 为不完整类型
// 不完整类型一般可定义指针或者声明作为返回值或者参数的函数
// 允许类中包含指向自己的指针和引用
// 在使用时必须被完整定义
class Window_mgr{ // 2. 定义Window_mgr类,只声明clear函数
    void clear(ScreenIndex ); //  clear函数中要使用到Screen类所以只是声明
    ...
};
class Screen{  // 3. 定义Screen类
    friend void Window_mgr::clear(ScreenIndex );
    ... 
};
void Window_mgr::clear(ScreenIndex a){...}  // 4. 具体定义成员函数
```
- 友元定义的位置 : 友元不受访问说明符的影响可以随处放,一般在类的开始或者结束处
- 友元声明 : 类中的友元声明只是指定了访问权限,需要在类的头文件中额外再进行一次声明,重载的友元函数需要每个版本都要在类中进行一次友元声明
```c++
	struct X{
		friend void f(){...}
		X(){f();} // f()未声明,错误
		void g();
	};
	void f();  // 即使f()定义在了类中,仍然需要再进行一次声明
	void X::g(){return f();}
```



### 3. 其他特性
#### 隐式的类类型转换
- 一个参数的构造函数称为转换构造函数,该参数类型的对象可作为该类型中间临时量使用,但不允许二次转换
- explict只作用于一个参数构造函数前,抑制隐式类类型转换,同时explict只作用于类中的函数声明前不做用于类外
- 拷贝初始化不能使用explict构造函数,可以通过static_cast来强制使用explict进行隐式类型转换
```c++
class A{
	A(string s){}
	explict A(int a){}
};
void func(A& b){}
string s="123";
func(s); // 正确 , string -> A
func("123"); // 错误 , "123" -> string -> A
func(string("123")); // 正确 , 显示使用构造函数
func(static_cast<A>(123)); // 强制 , 通过static_cast强制使用explict构造函数
```

#### 聚合类
- 聚合类作用 : 只是将数据成员单纯地聚合在一块,用户可以直接访问类成员,有特殊的初始化语法形式
- 聚合类条件 :
> - 所有成员都是 public
> - 没有定义任何构造函数
> - 没有类内初始值
> - 没有基类,没有virtual函数

- 聚合类初始化 : `Data var = {0, "123"};` , 顺序与声明顺序一致,剩余默认初始化 

#### 字面值常量类
- 聚合类数据成员都是字面值类或符合以下要求:
> - 数据成员都是字面值类型,类内初始值须是一条常量表达式
> - 类至少有一个constexpr构造函数,空函数体,可以设为default
> - constexpr成员函数必须符合constexpr函数要求,且是隐式const成员函数
> - 其他类型类成员需使用自己的constexpr构造函数
> - 必须使用析构函数的默认定义

#### 类的静态成员
- 静态成员 : 类对象不包含任何与静态成员有关的数据,而是与类共享,用static修饰类成员
- 静态数据成员 : 只能初始化一次,定义后一致存在于程序整个声明周期中
- 静态函数成员 : 不能声明成const,不与任何对象绑定,没有this指针
```c++
const int B=3;
int A::a=3;  // 类外初始化静态成员,处于类定义之前,static只出现在类中
class A{
	static int a;
	static constexpr int b=B; // 类内初始化静态成员,必须是constexpr,初始值必须是const 整数类型
	double aa[b]; // 用于编译器替换则不用在类外定义,其他情况需要额外定义
// 所以一般都在类外定义

	static void ff(){...}
	// Classname::ff(); , var.ff(); , pvar->ff(); 调用
};
```

- 静态成员与非静态的区别 : 静态成员可以是不完全类型(定义静态的自身类型成员) , 静态成员可以作为成员函数的默认实参


