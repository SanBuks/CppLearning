# 0. 代码风格的目标

## 每一个规则都应该“有效” 
规则带来的益处必须大到可以规定所有人去记住它。益处则通过以当前代码库为基础对比遵循和不遵循而衡量出来，所以一个规则即使反对了一个非常糟糕实践，但是人们都不太可能会做，这样只会产生有限的益处。

这一原则主要解释了为什么一些规则我们没有包含，而不是包含了一些规则：比如  `goto`  违反了接下来很多的原则， 但是已经近乎绝迹，所以风格指南没有讨论它。

##  为读者优化而非写者
我们当前代码库预期要维护很长时间，导致了更多时间是花在读而非写上。我们明确地选择为标准水平读者优化，维护和调试而非为写优化。

给读者留下痕迹只是这一原则下非常普通的要求，当一小段代码干了会让人吃惊或者不寻常的事，留下一小段提示会非常有益（比如将 raw 指针传递给函数的 `std::unique_ptr` 参数时用时会隐式转移所有权）

## 与现有代码库保持一致性
在现有代码库中使用同一种风格让我们可以把注意力放在其它 (更重要的) 事上。一致性让自动化成为可能，只要你的代码符合自动工具的预期就可以用工具排版或者调整 include 的次序。

在大部分情况下，目标是为了一致性的规则都可以简要概括为 “随便选一个（规则然后履行），不要再想它了” 。允许一定自由的潜在价值远远小于人们为它而争辩的成本，然而， 一致性还是有它的局限， 所以在没有明显技术争议和特定的长期发展方向下，保持一致性显然更胜一筹。

一致性规则因项目， 文件甚至一组精密关联的接口而异，所以一致性不应该被泛泛地拿来当做墨守成规的理由 或者 拿来当作现有代码库随时间而更新的发展趋势。

##  当合适的时候才与更开放的C++社区保持一致
与其他组织保持一致C++风格的理由与我们在现有代码库上保持一致风格是一样的。

如果某一个 Standard 特性解决了一个问题或者是某种 idiom 广为人知且被接受，这就没有理由不用它，但是，有时候 Standard特性 或 idiom 是有缺憾的 或者 没有考虑我们的代码库基础上设计出来。在这些情况下，限制或禁止一些特性是合适的。

在某些情况下， 我们更倾向于使用自己开发或者第三方库而不是标准库，这是出于对这些库的信任和将现有代码库转换为标准接口是价值有限的。

## 避免惊奇或危险的构造
C++有一些比看上去更加惊奇或危险的特性，某些规则既是为了防止陷入这些陷阱，舍弃这些规则是很难的，因为这会给很多代码带来危险。

## 避免一些大部分C++程序员都觉得难以维护的构造
C++有一些特性给代码带来了太多复杂性，因此并没有没有对大部分情况都合适。

在被广泛使用的代码（基础代码）中，使用这些复杂构造可能更合适，因为任何一点复杂实现带来的好处都会因为广泛的用途而放大，而且在编写新代码时不用再对这些代码的付出理解成本。因为这条规则而疑惑时，最好咨询下项目管理者。

这条规则对于我们的现存代码库是非常重要的，因为随时间人员流动很大，即使现在所有人对于某个部分代码都理解了，也很难保证未来几年仍然理解。

## 注意我们的代码规模
在 1亿+ 行代码和数千工程师的基础上，一个工程师的错误和过度简化都会导致很大的代价。列如，避免全局命名空间污染尤为重要：如果每个人都在全局命名空间下定义些对象，那么名称冲突在 1亿+ 行代码下就会难以忍受而且难以避免。

## 必要时让位于性能
某些时候，性能优化是必要且合适的，即使与一些原则冲突时。

## 最后
本文意图提供最大的指导和合理的限制。如往常一样，常识和好的风格需要提倡。对此，我们主要参考了整个Google C++社区的常规惯例而不只是你个人或团队的喜好。对一切聪明的，不常规的构造保持质疑和审慎的态度：毕竟没有明文禁止 和 正在处理的授权还是不一样的。自己判断，如果不确定，请向项目领导获取额外的建议。

# 1. 头文件

## 自给自足
- 自给自足 ： 可以作为第一个头文件进行编译, 任何头文件应该以 `.h` 结尾，且与一个`.cc` 源文件相关联（单元测试源文件除外）
- 模板与内联函数的声明和定义 都该放在同一个头文件中，其次舍弃过去可能使用的做法：定义放在`-inl.h` 文件中然后头文件中再包含
- 如果模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 `.cc` 文件里
- 只用作纯文本插入（文件中的特殊位置，不一定是文件开头）， 非自给自足， 没有头文件保护， 没有需要首先包含的头文件放在`.inc` 文件

## 头文件保护
- `<PROJECT>_<PATH>_<FILE>_H_`

## 只包含你所用的
- 如果源文件或头文件用到某个其他地方定义的 symbol，应当直接包含 恰好用于提供该声明或定义的文件，而不该因为其他原因包含其他文件 
- 不依赖头文件相互包含的关系，这可以使得用户去除不必要的头文件而不发生错误，比如`foo.cc`要包含 `bar.h` 则应当直接包含它，即使 `foo.h` 包含了 `bar.h`

## 前置声明
> 个人认为这里的头文件类似 \<iosfwd\> , PIMPL 可以使用，环形声明可以使用模板替代

- 尽可能地避免使用 前置声明 而是 包含头文件
- 优点：前置声明节省编译时间不用再处理头文件包含，防止头文件改动而重新编译
- 缺点：
    - 节省编译时间所带来的问题即跳过重新编译的过程，隐藏了依赖关系
    - 难以让自动分析工具判断实际定义 symbol 的模块在哪
    - 前置声明不能随同后续定义的改动而产生错误，比如：前置声明的函数或模板无法与后续增加了函数型参或模板型参， 把某个对象标识符放入命名空间中等同步
    - 来自命名空间 std:: 前置声明标识符会产生未定义情况
	- 前置声明和头文件在一般情况下难以判断好坏，在极端情况下前置声明会产生歧义（比如隐藏继承关系）
	- 有时比单一行的 include 冗长
	- 使用成员对象的指针会使得 代码复杂 且 增加时间成本

## 内联函数
- 只对10行或更少的函数定义
- 谨慎对构造和析构函数内联
- 不要对包含循环的函数进行内联（除非循环很少用到），虚函数和递归函数即使内联也不会实际内联
- 虚函数内联的主要原因则是想把它的函数体放在类定义内, 主要为了 图个方便 或 当作文档描述其行为, 比如该虚函数是精短的存取函数

## 包含的名称和顺序
- 顺序：关联的头文件 | C库 | C++库 | 其他库头文件 | 项目头文件 | 额外的条件编译 （ ‘ | ’ 代表空行）
- 包含项目头文件时不要包含相对路径， 在同一层级下对头文件进行字母顺序排序，同时不要因为头文件关系省略一些头文件（起到明示作用）
```c++
// 比如 foo.cc 具体如下
#include "foo.h"  //  如果出错， 与维护文件人有关的信息会最先呈现出来

#include <stdlib.h>

#include <algorithm>

#include "other_library.h"
#include "project_library.h"

#ifdef LANG_CXX11
#include <initializer_list>
#endif
```

# 2. 作用域

## 命名空间
- 除非特例，将代码放入命名空间中（也有缺点如迷惑性，冗长）
- 规定 ： 
    - 不使用 using语句（污染命名空间） 和 内联命名空间（主要用于版本控制）
    - 命名空间名称必须唯一，可以是路径
    - 不要在命名空间 std 内声明任何东西，包括标准库的类前置声明，这产生未定义的行为，不可移植
    - 不要在头文件中使用 命名空间别名 除非显式标记内部命名空间使用。因为任何在头文件中引入的命名空间都会成为公开API的一部分。
```c++
//  In the .h file 排除一些头文件或前置声明
namespace mynamespace {  // 范围到文件结尾
// 空一行 不缩进
class MyClass {
 public:
  ...
  void Foo();
};

}   // namespace mynamespace 额外注释


// 在 .h 中使用别名缩短常用的命名空间
namespace librarian {

namespace impl {  // 仅限内部使用

namespace sidetable = ::pipeline_diagnostics::sidetable;
...
}  // namespace impl

inline void my_inline_function() {
  // 限制在一个函数中的命名空间别名
  namespace baz = ::foo::bar::baz;
  ...
}
}  // namespace librarian
```

## 内部链接
- 如果在源文件中的某个对象的定义不会被其他文件所引用，则将他们放入匿名命名空间中来内部链接，或者声明为 static。不要在头文件中使用匿名命名空间和声明变量为static
- 确保无法被其他文件所引用，防止命名冲突

## 非成员函数、静态成员函数和全局函数
- 将非成员函数放入命名空间，尽量不要用裸的全局函数
- 不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关
- 非成员函数应尽量不依赖外部变量，应当尽量存在某个命名空间中
- 必须定义非成员函数, 又只是在 .cc 文件中使用它，可以使用内部链接方法

## 局部变量
- 尽量减少函数变量的作用域，尽量延后定义，一定初始化。
- `while (const char* p = strchr(str, '/')) str = p + 1;` 减少作用域，（对象则例外要比较构造和析构成本高还是赋值成本高）

## 静态和全局变量

- 规则 ： 
    - 禁止 非Trivial destructor 的 静态存储周期 对象
    - 静态函数局部对象可以使用动态初始化 但是不鼓励 对类静态数据成员 或 命名空间中定义的对象 进行动态初始化（有特列）
    - 根据经验，全局变量满足（上述）条件，可以被声明为constexpr（单独地来说）




# 3. 类

# 4. 函数

# 5. Google特殊工具

# 6. 其他特性

# 7. 命名约定
> 名字要有描述性, 少用缩写, 除非常见且无歧义的缩写

## 文件名 
- 小写 + 下划线 `my_file_name.cc`
- 拓展名 为 .cc 或 .h 
- 内联函数放入.h 文件中
- 不要与 /usr/include 下文件名重复

## 类名
- 词首字母大写, 无下划线 `ClassName`
- 适用 类, 结构体, 类型别名, 枚举

## 变量
- 小写 + 下划线 :  `my_variable`
- 类数据成员(静态/非静态), 后加下划线 :  `my_member_variable_`
- 结构体数据成员, 当作一般变量 :  `my_struct_variable`
- 全局变量, 前加g  : 如 `g_my_global_variable`
- 常量(局部/全局)前加k, 词首字母大写 :  如 `kMyConstName`

## 函数
- 每个词首字母大写, 无下划线 :  `FuncName()`
- 成员函数要与数据成员对应 : `my_variable()` , `set_my_variable()`
- 某函数出错就直接crash加上 OrDie : `FuncNameOrDie()`

## 枚举
- 枚举值优先遵循常量命名法
- 枚举值也可以遵循宏命名法 ( 全大写 )

# 8. 注释
## 文件注释
- 版权声明 (比如, Copyright 2008 xxxx Inc.) 
- 许可证 (比如, Apache 2.0, BSD, LGPL, GPL)
- 作者 (标识文件的原始作者)
- .h 文件要对所声明的类的功能和用法作简单说明
- .cc 文件通常包含了更多的实现细节或算法技巧 (如果这些对于理解 .h 文件有帮助, 可挪到 .h, 并在 .cc 中指出)

## 类注释
- 类的使用方式
- 要特别注意说明多线程环境下相关的 规则和常量使用

## 函数注释
### 函数声明
- 使用叙述式而非指令式说明函数功能, 避免不言而喻的注释如 : 析构或构造, 构造函数对参数处理和析构的对资源的清理有特别之处
- 函数的输入输出, 参数是否可以为 NULL; 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数; 资源由谁释放
- 是否存在函数使用上的性能隐患, 如果函数是可重入的, 其同步前提是什么
### 函数定义
- 注释说明函数功能和实现要点, 比如编程技巧, 实现的大致步骤, 或解释如此实现的理由, 为什么前半部分要加锁而后半部分不需要
- 不要 从 .h 文件或其他地方的函数声明处直接复制注释
- 简要重述函数功能是可以的, 但注释重点要放在 如何实现上

## 变量注释
- 如果变量可以接受 NULL 或 -1 等警戒值, 须加以说明
- 是否能够越界, 上限规定
- 额外补充变量名的注释

## 实现注释
- 行注释 : 行尾空两格
- 向函数传入 NULL, 布尔值或整数时, 要注释说明含义, 或使用常量让代码望文知意
- 多行注释注意对齐
- 不要自然语言翻译代码

## TODO
- TODO 注释要使用全大写的字符串 TODO
- DEPRECATED标 记某接口为弃用状态, 放在接口声明前, 需要修改调用点
行。
```c++
// TODO(kl@gmail.com): Use a "*" here for concatenation operator.
// TODO(xxxx): xxxx. Fix by YYYY-MM-DD
// DEPRECATED(xxxx): xxxx 
```

# 9. 格式
## 基础格式
- 行长不超过80 例外如下 :
	- 注释包含url 或 其他命令可以超过
	- #include 包含路径可以超过
	- 头文件保护可以超过
- 编码格式 : 源代码用 utf-8 编码, 少出现非 ASCII 字符, 用 u8 前缀修饰字符串字面值
- 缩进格式 : 只用空格缩进, 每次缩进 2 个空格
- 函数格式 : 返回类型和函数名在同一行, 参数尽量在同一行
```c++
ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,
                                             Type par_name3) { // ) {
  DoSomething();
  ...
}
ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
    Type par_name1,  // 4 space indent
    Type par_name2,
    Type par_name3) {
  DoSomething();  // 2 space indent
  ...
}

// 短小的内联函数可以特殊
Foo(int b) : Bar(), baz_(b) {} // 大括号里面是空的话，不加空格。 void Reset()
void Reset() { baz_ = 0; } // 用括号把大括号与实现分开。
/*
1. 返回类型与函数定义放不下分行, 不缩进
2. 函数名 与 ( 间没有空格, 圆括号 与 参数 间没有空格
3. 花括号与最后一个参数在同一行, 右括号自成一行, 至少 { }
5. 形参必须有名字且一致, 如果没有用到形参需要用注释标记无用形参名 换行后的参数是4空格缩进
*/
```

- 函数调用 : 
    - 尽量放在一行, 否则分行对齐
    - 如果第一个参数放不下, 则所有参数都分行, 每行缩进4格
    - 中间量计算可以通过临时变量增加可读性, 或者直接分行注释
- 列表初始化 :
    - 与函数调用相同, 将变量当作为函数名
    - 分行时可以在 { 后分行(4空格缩进), 或者第一个初始化参数后分行
- 条件语句 : 
    - `if (condition) {`
    - `} else {`
	- 如果没有 else 还是要加加 '{' (goto fail!) , 否则必加 '{' 
```c++
if (condition) {
  ...
} else { // 括号必配套
  ...
}
```

- 循环语句 : 
    - switch : case间可以加花括号标注不可相连
    - 空循环体使用 continue;
```c++
switch (var) {
  case 0: {  // 2 space indent, 0:
    ...      // 4 space indent
    break;
  }
  case 1: {
    ...
    break;
  }
  default: {
    assert(false);  // 断定 default 永远没有执行到可以加上 assert(false);
  }
}
for ( ; i < 5; ++i)  //第一个空条件需要有一个空格
```

- 指针引用表达式 : 
    - `.`, `->`, `*`, `&` 之后没有空格
	- 修饰符选择尽量后置
- 布尔表达式 : 可以让逻辑运算符置于行末来分行, 必要加 () 增加可读性
- return : 没必要都加(), 布尔表达式可加
- 初始化 : 优先选择用 {} 初始化, 再 (), 最后为 = 
- 预处理命令 : 置于行首, 不缩进

## 类,模板等格式
- 访问控制符 : 
    - 1 格缩进, 如 `public:`
    - 先 public 再 protected 再 private
    - 控制符前空一行, public不用
- 构造函数
```c++
// When everything fits on one line:
MyClass::MyClass(int var) : some_var_(var) {
  DoSomething();
}

// If the signature and initializer list are not all on one line,
// you must wrap before the colon and indent 4 spaces:
MyClass::MyClass(int var)
    : some_var_(var), some_other_var_(var + 1) { }
```

- 名字空间 不要增加额外的缩进层次
- 嵌套命名空间时，每命名空间都独立成行
- 尖括号不与空格紧邻，< 前没有空格，>( 之间也没有
- 不在万不得已, 不要使用空行
- return; 不是 return ;  没必要可以省略 return

# 10. 例外
- 提高 warning 级别`-Werror -Wall -Wextra -pedantic`
- 使用 /FI 编译器选项以自动包含要编译的文件