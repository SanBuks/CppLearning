> 恰如其分的命名, 来自于恰如其分的灼见 (Pierre Bonnard)

# 1. 命名空间的寻找
早期的风格指南中存在一条规定, 简言之就是, 参照 JAVA 的包名要求, 每个包名对应一个文件夹, 与之相应的, 就是每个命名空间对应一个文件夹. 

确实, 从表面上看, 标识符名字会因此独特, 这种命名风格也容易维持一致, 但是实际上却并不是这样美好 : 

```c++
// c++
namespace foo {
namespace bar {  // 风格指南的要求, 命名空间不缩进
void f() {
  Baz b;  // 命名空间中未声明的 Baz 类型
  /* 
   *  1. 先在 f() 中寻找
   *  2. 再在 bar 中寻找
   *  3. 最后在 foo 中寻找 
   */
}
}
}

// java
// java 中没有未声明的标识符, 每个标识符都是确切限定的, 如下
import com.google.foo.bar.Baz;
Baz b = new Baz();  
// 等效为
com.google.foo.bar.Baz b = new com.google.foo.bar.Baz();

// 即使通配符出现, 也仅仅是在 bar 这个包中引用相应对象
import com.google.foo.bar.*;
```

JAVA 不会对未声明的标识符向外层包中寻找目标, 而 CPP 会逐一向外层命名空间中寻找目标. 

这就决定了在 CPP 中用文件结构化的命名空间结构注定是一个错误

# 2. 普遍的错误
一个最普遍的 "错误" 是我们很少用全限定标识符, 比如我们经常写 `std::unique_ptr` 而非 `::std::unique_ptr` 这会出现什么问题呢 ? 
```c++
// 在 ::division::section::team::subteam::project 工作目录下
// std::unique_ptr 可能是以下任何一种

::std::unique_ptr
::division::std::unique_ptr
::division::section::std::unique_ptr
::division::section::team::std::unique_ptr
::division::section::team::subteam::std::unique_ptr
::division::section::team::subteam::project::std::unique_ptr

// 这意味着, 在命名空间的树结构上(以全局为根), 只要祖先节点的儿子节点中有任何一个可以与命名重合的命名空间和标识符则会覆盖上一层的需要寻找的同名标识符
```

非常明显的教训就是, 从不要让子命名空间与顶层命名空间撞名, 尤其是 std

但是这就够了吗 ? 

![](D:\Project\LEARNING\cpp_learning\coding_style\tip_of_the_week\image\cpp_name_find.png)

如果代码行数大, 项目多, 每个项目在自己的命名空间下命名了通用的名字 如 util, testing 等, 会存在覆盖上层命名空间的情况发生, 这简直是产生命名冲突的 "良方"

对比 JAVA, 如果在两个包中产生了命名冲突, 编译报错, 这完全可以取消通配符来轻松解决所有问题

# 3. 两个目标, 三个方法
有两个目标, 达到了可以远离这种困扰 :

第一个目标, 如上述所说的, 防止底层命名空间与标识符 覆盖 顶层的命名空间与标识符的情况出现

第二个目标, 用全限定标识符, 防止名字查找

有至少三种方法可以达到这些 : 

第一个方法, 用全限定符如 `::std::string`, 与所有的风格相左

第二个方法, 用工具分析命名空间树, 检测第一个目标所描述的状态

第三个方法, 不要嵌套过深, 一个顶层命名空间对应一个项目, 不耦合在一起, 这样减少了长的名字, 减少了暴露的风险

现在由于历史代码问题, 保留原来的最初的规定, 但是如果有可能, 则一定会采用第三个方法, 会为每个项目采用的公共接口创建一个顶层命名空间. 

# 4. 为什么不结构化
经常会听到有人表达, 把一切都结构化, 比如为什么要把 StrCat 和 make_unique 放在一起, 为什么不用 `absl::strings::utilities` 区分 ? 

这是因为每一个为了结构化而添加的父命名空间名字 (前缀) 会影响到上一层标识符的可见性, 所以为了结构化而过深嵌套的结构会加剧冲突

# 5. 最佳实践
维护一个命名空间的数据库

当创建一个新的命名空间时, 参考它或者以它为顶层命名空间

前两项不可能实现时, 尽量不要创建与 (未来的) 顶层或者高层命名空间撞名的子空间

使用空间别名或者 using 声明时, 用全限定标识符, 除非是引用本命名空间的子空间

对于在 util 或 其他通用命名空间中的标识符而言, 尽量少做全限定 (为了项目的健壮), 但是必要时要做全限定