# 1. 定义抽象数据类型
## 1.1 类的思想
### 数据抽象
- 数据抽象实质是对具体数据模型的抽象, 通过定义一个抽象数据类来代表某种数据模型通用的操作和数据的关系
- 其中函数成员定义模型的操作, 数据成员定义数据及数据的关系
- 通过实例化对象来通过同一组接口对不同具体模型达到类似的操作的效果

### 封装
- 接口 与 实现和数据 分离, 产生抽象数据类型(封装了实现细节的数据类型)
- 使用者了解接口即可使用, 设计者仅根据接口要求自行改变实现细节
- 访问控制加强封装性

## 1.2 成员函数
- 成员函数通过 this 常量指针 来调用对象
- 定义在类中函数为隐式内联函数, 类外定义的函数其函数类型, 函数名和 this 常量性都需一致
- 类外则非内联函数可用 inline 显示声明为内联函数 
- 常量成员函数的 const 加在参数列表后面, 修改this的属性为指向常量对象的常量指针
- mutable : 修饰数据成员, mutable 成员可在 const 成员函数 和 const 类对象 中被修改
```c++
class A {
    std::string isbn() const { };
    // 等价为
    // 1. std::string isbn(const className * const this);
    
	// 2. 返回 int & 则出错,不可修改成员
	const int &ff(int a) const { return a;} 
    // 成员函数返回 *this 可以作为 类的左值使用, 符合赋值运算符的结果
    // const成员函数 返回 *this, 则返回类型是常量引用
    
	// 3. 成员函数的 const 重载 :
    // 基于对象是否是const,存在基于const的成员函数重载
    // 类似于 const int *p 和 int *p 的重载
    const A&ff() const { return *this; }
	int &ff(const int &a){ return a; }  // 根据类A是否是const发生调用ff()的重载
	int a=3;

	// 4. 类中编译规则: 先编译成员声明,再编译成员的函数体(如果有),因此数据成员可以随意放
};
```

## 1.3 构造函数
- 构造函数 : 控制初始化过程, 对象被创建就会执行, 可重载, 与类同名, 无返回, this 非底层const
### 默认构造函数与合成默认构造函数
- 默认构造函数 : 空参或都提供默认实参的构造函数
- 使用默认构造函数 :
    - ClassName obj
    - 类数据成员默认初始化
    - 值初始化 vector\<T> vec(n)
- 合成的默认构造函数 : 没有自定义构造函数时由编译器生成, 依次完成两件事
    - 存在类内的初始值, 则用它初始化类成员
    - 默认初始化成员
- =default : 显示合成默认构造函数, 内部默认内联, 外部不内联
### 初始值列表
- 初始值类列表初始化了成员并简化了构造函数体
```c++
class A{
	int d1, d2, &d3;
    int d4 = 3;
    B b = {};
public:
    // 1. 初始化顺序按声明顺序来, 并不按列表顺序
    // 2. const 或 引用等成员必须使用初始值列表来初始化,不能用函数体赋值语句
	A(int a1) : d3(d1), d1(a1){ // d1先初始化, d2默认初始化, d3最后初始化
        // 初始值列表初始化优先于类内初始值
		d1=2; // d1后在函数体中再次被赋值
	}
    // 3. 未在初始值列表中出现的对象 (d2, d4, b) 会根据类内初始值初始化
};
```
### 委托构造函数
- 委托构造函数 : 在参数列表中调用其他的构造函数, 执行顺序 : 
    - 从委托的构造函数初始化列表 -> 
    - 委托构造函数的函数体 -> 
    - 构造函数剩余的初始值列表 ->
    - 构造函数的函数体

## 1.4 类的作用域
- 类外定义函数的作用域 : 
```c++
ClassName::AliasType ClassName::Funcname(const int &a) const {....} 
// ClassName::后的参数列表,函数体都处于类作用域中
// 返回值类型默认不在,可加上 Classname:: 补充
```

- 类中类型别名 : 类中的类型别名需要先定义再使用, 一般放在类开头 且是 public
```c++
// 不能重复定义作用域外的类型别名
typedef double Money;
class A {
 public:
  Money test() { return 30.2F; }  // 成员使用了外层作用域中的某个类型别名
  typedef int Money;  // 那么在类中就不能重新定义该名字,否则会发生错误
  
};
```

- 名字查找规则 : 
    - 成员函数体内查找,注意包含形参的隐式定义
    - 类中所有成员
    - 成员函数定义前的作用域内查找 (注意 ! 包含类定义到类外定义的范围) 
```c++
class A{
public : 
	int ff(); // 第二层查找范围
};
int a=3;  // 第三层查找范围
int b=4;  // 第三层查找范围
int A::ff(){ 
  // 第一层查找范围
  // 从类作用域出来找到了定义之前范围内的 a
  return a; 
}  
```

- 形参与类成员同名 : 
  - `this->attr` 或者 `classname::attr` 可以避免参数名和成员重名的问题
  - `::var` 可以避免全局变量与成员或者参数重名的问题

# 2. 访问控制
## 2.1 访问说明符
- public 说明符后的成员在整个程序内可以访问, 可定义类的接口
- private 说明符后的成员在程序内不可访问, 只能被类的成员函数访问
- 说明符可重复使用多次, 范围根据位置进行划分
- class 的默认说明符为private , struct 的默认说明符为public, 除此之外没有区别

## 2.2 友元
- 友元定义 : 指类或函数允许访问一个类的非public成员, 用friend声明该函数或者类, 友元关系不具备传递性
- 前向声明 : 在定义友元时需要用前向声明来处理交织的依赖关系
```c++
// 定义友元时的 声明顺序

// 1. 前向声明类 Screen 为不完整类型 (在使用时必须被完整定义)
class Screen;  
//    1.1 可以定义不完整类型的指针 或 
//    1.2 作为函数的参数或返回类型 或 
//    1.3 作为模板类型 (模板没实现)
//    1.4 允许类中包含指向自己的指针和引用

// 2. 定义Window_mgr类, 只声明clear函数
class Window_mgr{ 
    using ScreenIndex = vector<Screen>::size_type;
    void clear(ScreenIndex ); //  clear函数中要使用到Screen类所以只是声明
    ...
};

// 3. 定义Screen类
class Screen{  
    friend void Window_mgr::clear(ScreenIndex );
    ... 
};

// 4. 具体定义成员函数
void Window_mgr::clear(ScreenIndex a){...}  
```

- 友元声明不受影响的情况 : 友元不受访问说明符影响, 不受类成员声明顺序影响, 一般在类的开始处声明
- 友元声明(定义)是特殊的声明 :  一言以蔽之, 友元声明作用只是规定影响权限, 不对作用域有影响
    - 定义在类内部的友元函数是内联的, 但是不规定作用域对友元的声明 
    - 友元需要在类的头文件中, 类外额外再进行一次声明
    - 重载的友元函数需要每个版本都要在类中进行一次友元声明
```c++
struct X{
    friend void f(){...} // 即使定义了友元函数, 类作用域中该友元仍然不可见
    X(){f();}  // 错误, 即使友元f()定义在了内中仍要一个前置的声明
    void g();
	void h();
};
void X::h(){ f(); } // 错误, 即使友元f()定义在了内中仍要一个前置的声明
void f();  // 即使f()定义在了类中,仍然需要再进行一次声明
void X::g(){ f(); }
```

# 3. 其他特性
## 3.1 隐式的类类型转换
- 转换构造函数 : 一个参数的构造函数, 该参数类型的对象隐式转换为该类临时量使用, 但不允许二次转换
- explict : 只作用于一个参数构造函数声明前, 抑制隐式类类型转换(包括拷贝初始化)
```c++
class A{
	A(string s){}
	explict A(int a){}
};
void func(A& b){}

string s="123";
func(s); // 正确 , string -> A
func(string("123")); // 正确 , 显示使用构造函数

func("123"); // 错误 , "123" -> string -> A
func(static_cast<A>(123)); // 通过 static_cast 显示执行了 explict 构造函数
```

## 3.2 聚合类
- 聚合类作用 : 只是将数据成员单纯地聚合在一块, 用户可以直接访问类成员, 有特殊的初始化语法形式
- 聚合类条件 :
    - 所有成员都是 public
    - 没有定义任何构造函数
    - 没有类内初始值
    - 没有基类, 虚表
- 聚合类初始化 : `Data var = {0, "123"};` 顺序与声明顺序一致, 剩余默认初始化 
## 3.3 字面值常量类
- 成员都是字面值类型的聚合类是字面值常量类
- 自定义的字面值常量类要求 :
    - 至少有一个constexpr构造函数, 空函数体, 初始化所有成员, 可以设为default, 存在类内初始值则须是一条常量表达式
    - 必须使用析构函数的默认定义
    - 数据成员都是字面值类型, 其他类型类成员须是字面值常量类, 成员函数必须符合constexpr函数要求且是隐式const
## 3.4 类的静态成员
- 静态成员 : 类对象不包含任何与静态成员有关的数据, 而是与类共享, static 只作用于声明
- 静态数据成员 : 只能初始化一次, 定义后一致存在于程序整个声明周期中
- 静态函数成员 : 不能声明成const, 不与任何对象绑定, 没有this指针
```c++
const int B=3;
int A::a=3;  // 1. 类外且类定义之前初始化静态成员, static 只出现在类中
class A{
	static int a;
	static constexpr int b=B; 
	// 2. 静态成员一般不在类内初始化除非满足以下条件 :
	//  (1) 静态成员必须是constexpr修饰 或 const 修饰的字面值
	//  (2) 初始值必须是常量表达式
    
	double aa[b]; 
	// 3. 类内初始化的静态成员只用于编译期替换可以不用在类外定义, 其他情况需要额外定义
    //    类内初始化的静态成员可用于常量表达式的地方如 数组下标
    // 4. 类内初始化的静态成员, 类外定义可没有初始值

    // 非静态成员的类内初始化会在动态期间初始化, 会被初始化列表初始值覆盖 
    
	static void ff(){...}
	// 5. Classname::ff(); , var.ff(); , pvar->ff(); 三种调用方式
};
```

- 静态成员与非静态的区别 :
```c++
class A {
  // 静态成员可以是不完全类型比如定义自身类型的数据成员
  static A a;  
  // 静态成员可以作为成员函数的默认实参
  void test(A test = a);
};
```